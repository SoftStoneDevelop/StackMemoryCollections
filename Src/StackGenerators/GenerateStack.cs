using Microsoft.CodeAnalysis;
using System.Collections.Generic;
using System.Text;
using System;

namespace StackGenerators
{
    public partial class Generator
    {
        private void GenerateStack(
            in List<INamedTypeSymbol> typeStack,
            in GeneratorExecutionContext context,
            in Dictionary<string, TypeInfo> typeInfos
            )
        {
            var helperBuilder = new StringBuilder();
            for (int i = 0; i < typeStack.Count; i++)
            {
                var currentType = typeStack[i];
                helperBuilder.Clear();
                if (!typeInfos.TryGetValue($"{currentType.ContainingNamespace}.{currentType.Name}", out var typeInfo))
                {
                    throw new Exception($"Type information not found, types filling error. Type name: {currentType.ContainingNamespace}.{currentType.Name}");
                }

                helperBuilder.Append($@"// <auto-generated by Brevnov Vyacheslav Sergeevich/>
using System;
using {currentType.ContainingNamespace};

namespace {currentType.ContainingNamespace}.Struct
{{
    public unsafe struct StackOf{currentType.Name} : IDisposable
    {{
        private readonly StackMemoryCollections.Struct.StackMemory* _stackMemoryS;
        private readonly StackMemoryCollections.Class.StackMemory _stackMemoryC = null;
        private readonly void* _start;

        public StackOf{currentType.Name}()
        {{
            throw new Exception(""Default constructor not supported"");
        }}

        public StackOf{currentType.Name}(
            nuint count,
            StackMemoryCollections.Struct.StackMemory* stackMemory
            )
        {{
            if (stackMemory == null)
            {{
                throw new ArgumentNullException(nameof(stackMemory));
            }}

            _start = (*stackMemory).AllocateMemory({currentType.Name}Helper.GetSize() * count);
            _stackMemoryS = stackMemory;
            Capacity = count;
        }}

        public StackOf{currentType.Name}(
            nuint count,
            StackMemoryCollections.Class.StackMemory stackMemory
            )
        {{
            if (stackMemory == null)
            {{
                throw new ArgumentNullException(nameof(stackMemory));
            }}

            _start = stackMemory.AllocateMemory({currentType.Name}Helper.GetSize() * count);
            _stackMemoryC = stackMemory;
            _stackMemoryS = null;
            Capacity = count;
        }}

        public StackOf{currentType.Name}(
            nuint count,
            void* memoryStart
            )
        {{
            if (memoryStart == null)
            {{
                throw new ArgumentNullException(nameof(memoryStart));
            }}

            _start = memoryStart;
            _stackMemoryS = null;
            Capacity = count;
        }}

        public nuint Capacity {{ get; private set; }}

        public nuint Size {{ get; private set; }} = 0;

        public bool IsEmpty => Size == 0;

        public void ReducingCapacity(in nuint reducingCount)
        {{
            if (reducingCount <= 0)
            {{
                return;
            }}

            if (Size < Capacity - reducingCount)
            {{
                throw new Exception(""Can't reduce available memory, it's already in use"");
            }}

            if(_stackMemoryS != null)
            {{
                if (new IntPtr((*_stackMemoryS).Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to reduce available memory, stack moved further"");
                }}

                (*_stackMemoryS).FreeMemory(reducingCount * {currentType.Name}Helper.GetSize());
            }}
            else if (_stackMemoryC != null)
            {{
                if (new IntPtr(_stackMemoryC.Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to reduce available memory, stack moved further"");
                }}

                _stackMemoryC.FreeMemory(reducingCount * {currentType.Name}Helper.GetSize());
            }}

            Capacity -= reducingCount;
        }}

        public void ExpandCapacity(in nuint expandCount)
        {{
            if(_stackMemoryS != null)
            {{
                if (new IntPtr((*_stackMemoryS).Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to expand available memory, stack moved further"");
                }}

                (*_stackMemoryS).AllocateMemory(expandCount * {currentType.Name}Helper.GetSize());
            }}
            else if (_stackMemoryC != null)
            {{
                if (new IntPtr(_stackMemoryC.Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to expand available memory, stack moved further"");
                }}

                _stackMemoryC.AllocateMemory(expandCount * {currentType.Name}Helper.GetSize());
            }}

            Capacity += expandCount;
        }}

        public void TrimExcess()
        {{
            ReducingCapacity(Capacity - Size);
        }}


        public void Push(in {currentType.Name} item)
        {{
            var tempSize = Size + 1;
            if (tempSize > Capacity)
            {{
                throw new Exception(""Not enough memory to allocate stack element"");
            }}

            {currentType.Name}Helper.CopyToPtr(in item, (byte*)_start + (Size * {currentType.Name}Helper.GetSize()));
            Size = tempSize;
        }}

        public bool TryPush(in {currentType.Name} item)
        {{
            var tempSize = Size + 1;
            if (tempSize > Capacity)
            {{
                return false;
            }}

            {currentType.Name}Helper.CopyToPtr(in item, (byte*)_start + (Size * {currentType.Name}Helper.GetSize()));
            Size = tempSize;

            return true;
        }}

        public void Pop()
        {{
            if (Size <= 0)
            {{
                throw new Exception(""There are no elements on the stack"");
            }}

            Size--;
        }}

        public void Clear()
        {{
            if (Size != 0)
            {{
                Size = 0;
            }}
        }}

        public {currentType.Name} Top()
        {{
            if (Size == 0)
            {{
                throw new Exception(""There are no elements on the stack"");
            }}

            {currentType.Name} result = new {currentType.Name}();
            {currentType.Name}Helper.CopyToValue((byte*)_start + ((Size - 1) * {currentType.Name}Helper.GetSize()), ref result);
            return
                result;
        }}

        public void* TopPtr()
        {{
            if (Size == 0)
            {{
                throw new Exception(""There are no elements on the stack"");
            }}

            return (byte*)_start + ((Size - 1) * {currentType.Name}Helper.GetSize());
        }}

        public void Dispose()
        {{
            if(_stackMemoryS != null)
            {{
                (*_stackMemoryS).FreeMemory(Capacity * {currentType.Name}Helper.GetSize());
            }}
            else if (_stackMemoryC != null)
            {{
                _stackMemoryC.FreeMemory(Capacity * {currentType.Name}Helper.GetSize());
            }}
        }}

        public void* this[nuint index]
        {{
            get
            {{
                if (Size <= 0 || Size <= index)
                {{
                    throw new Exception(""Element outside the stack"");
                }}

                return
                    (byte*)_start + ((Size - 1 - index) * {currentType.Name}Helper.GetSize());
            }}
        }}

        public void Copy(in void* ptrDest)
        {{
            Buffer.MemoryCopy(
                _start,
                ptrDest,
                Capacity * {currentType.Name}Helper.GetSize(),
                Capacity * {currentType.Name}Helper.GetSize()
                );
        }}
    }}
}}
");
                context.AddSource($"{currentType.Name}StackStruct.g.cs", helperBuilder.ToString());

                helperBuilder.Clear();
                helperBuilder.Append($@"// <auto-generated by Brevnov Vyacheslav Sergeevich/>
using System;
using System.Collections;
using {currentType.ContainingNamespace};

namespace {currentType.ContainingNamespace}.Class
{{
    public unsafe class StackOf{currentType.Name} : IDisposable, System.Collections.Generic.IEnumerable<{currentType.Name}>
    {{
        private readonly StackMemoryCollections.Struct.StackMemory* _stackMemoryS;
        private readonly StackMemoryCollections.Class.StackMemory _stackMemoryC = null;
        private readonly void* _start;
        private int _version = 0;

        public StackOf{currentType.Name}(
            nuint count,
            StackMemoryCollections.Struct.StackMemory* stackMemory
            )
        {{
            if (stackMemory == null)
            {{
                throw new ArgumentNullException(nameof(stackMemory));
            }}

            _start = (*stackMemory).AllocateMemory({currentType.Name}Helper.GetSize() * count);
            _stackMemoryS = stackMemory;
            Capacity = count;
        }}

        public StackOf{currentType.Name}(
            nuint count,
            StackMemoryCollections.Class.StackMemory stackMemory
            )
        {{
            if (stackMemory == null)
            {{
                throw new ArgumentNullException(nameof(stackMemory));
            }}

            _start = stackMemory.AllocateMemory({currentType.Name}Helper.GetSize() * count);
            _stackMemoryC = stackMemory;
            _stackMemoryS = null;
            Capacity = count;
        }}

        public StackOf{currentType.Name}(
            nuint count,
            void* memoryStart
            )
        {{
            if (memoryStart == null)
            {{
                throw new ArgumentNullException(nameof(memoryStart));
            }}

            _start = memoryStart;
            _stackMemoryS = null;
            Capacity = count;
        }}

        public nuint Capacity {{ get; private set; }}

        public nuint Size {{ get; private set; }} = 0;

        public bool IsEmpty => Size == 0;

        public void ReducingCapacity(in nuint reducingCount)
        {{
            if (reducingCount <= 0)
            {{
                return;
            }}

            if (Size < Capacity - reducingCount)
            {{
                throw new Exception(""Can't reduce available memory, it's already in use"");
            }}

            if(_stackMemoryS != null)
            {{
                if (new IntPtr((*_stackMemoryS).Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to reduce available memory, stack moved further"");
                }}

                (*_stackMemoryS).FreeMemory(reducingCount * {currentType.Name}Helper.GetSize());
            }}
            else if (_stackMemoryC != null)
            {{
                if (new IntPtr(_stackMemoryC.Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to reduce available memory, stack moved further"");
                }}

                _stackMemoryC.FreeMemory(reducingCount * {currentType.Name}Helper.GetSize());
            }}

            Capacity -= reducingCount;
        }}

        public void ExpandCapacity(in nuint expandCount)
        {{
            if(_stackMemoryS != null)
            {{
                if (new IntPtr((*_stackMemoryS).Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to expand available memory, stack moved further"");
                }}

                (*_stackMemoryS).AllocateMemory(expandCount * {currentType.Name}Helper.GetSize());
            }}
            else if (_stackMemoryC != null)
            {{
                if (new IntPtr(_stackMemoryC.Current) != new IntPtr((byte*)_start + (Capacity * {currentType.Name}Helper.GetSize())))
                {{
                    throw new Exception(""Failed to expand available memory, stack moved further"");
                }}

                _stackMemoryC.AllocateMemory(expandCount * {currentType.Name}Helper.GetSize());
            }}

            Capacity += expandCount;
        }}

        public void TrimExcess()
        {{
            ReducingCapacity(Capacity - Size);
        }}


        public void Push(in {currentType.Name} item)
        {{
            var tempSize = Size + 1;
            if (tempSize > Capacity)
            {{
                throw new Exception(""Not enough memory to allocate stack element"");
            }}

            {currentType.Name}Helper.CopyToPtr(in item, (byte*)_start + (Size * {currentType.Name}Helper.GetSize()));
            Size = tempSize;
            _version++;
        }}

        public bool TryPush(in {currentType.Name} item)
        {{
            var tempSize = Size + 1;
            if (tempSize > Capacity)
            {{
                return false;
            }}

            {currentType.Name}Helper.CopyToPtr(in item, (byte*)_start + (Size * {currentType.Name}Helper.GetSize()));
            Size = tempSize;
            _version++;

            return true;
        }}

        public void Pop()
        {{
            if (Size <= 0)
            {{
                throw new Exception(""There are no elements on the stack"");
            }}

            Size--;
            _version++;
        }}

        public void Clear()
        {{
            if (Size != 0)
            {{
                Size = 0;
                _version++;
            }}
        }}

        public {currentType.Name} Top()
        {{
            if (Size == 0)
            {{
                throw new Exception(""There are no elements on the stack"");
            }}

            {currentType.Name} result = new {currentType.Name}();
            {currentType.Name}Helper.CopyToValue((byte*)_start + ((Size - 1) * {currentType.Name}Helper.GetSize()), ref result);
            return
                result;
        }}

        public void* TopPtr()
        {{
            if (Size == 0)
            {{
                throw new Exception(""There are no elements on the stack"");
            }}

            return (byte*)_start + ((Size - 1) * {currentType.Name}Helper.GetSize());
        }}

        #region IDisposable

        private bool _disposed;

        ~StackOf{currentType.Name}() => Dispose(false);

        public void Dispose()
        {{
            Dispose(true);
            GC.SuppressFinalize(this);
        }}

        protected virtual void Dispose(bool disposing)
        {{
            if (!_disposed)
            {{
                if (disposing)
                {{
                    if(_stackMemoryS != null)
                    {{
                        (*_stackMemoryS).FreeMemory(Capacity * {currentType.Name}Helper.GetSize());
                    }}
                    else if (_stackMemoryC != null)
                    {{
                        _stackMemoryC.FreeMemory(Capacity * {currentType.Name}Helper.GetSize());
                    }}
                }}

                _disposed = true;
            }}
        }}

        #endregion

        #region IEnumerable<T>

        public System.Collections.Generic.IEnumerator<{currentType.Name}> GetEnumerator()
        {{
            return new Enumerator(this);
        }}

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {{
            return new Enumerator(this);
        }}

        public struct Enumerator : System.Collections.Generic.IEnumerator<{currentType.Name}>, System.Collections.IEnumerator
        {{
            private readonly StackOf{currentType.Name} _stack;
            private void* _current;
            private int _currentIndex;
            private int _version;

            internal Enumerator(StackOf{currentType.Name} stack)
            {{
                _stack = stack;
                _currentIndex = -1;
                _current = default;
                _version = _stack._version;
            }}

            public {currentType.Name} Current 
            {{
                get
                {{
                    {currentType.Name} result = new {currentType.Name}();
                    {currentType.Name}Helper.CopyToValue(_current, ref result);
                    return result;
                }}
            }}

            object System.Collections.IEnumerator.Current => Current;

            public void Dispose()
            {{
                _currentIndex = -1;
            }}

            public bool MoveNext()
            {{
                if (_version != _stack._version)
                {{
                    throw new InvalidOperationException(""The stack was changed during the enumeration"");
                }}

                if (_stack.Size < 0)
                {{
                    return false;
                }}

                if (_currentIndex == -2)
                {{
                    _currentIndex = (int)_stack.Size - 1;
                    _current = (byte*)_stack._start + (_currentIndex * (int){currentType.Name}Helper.GetSize());
                    return true;
                }}

                if (_currentIndex == -1)
                {{
                    return false;
                }}

                --_currentIndex;
                if (_currentIndex >= 0)
                {{
                    _current = (byte*)_stack._start + (_currentIndex * (int){currentType.Name}Helper.GetSize());
                    return true;
                }}
                else
                {{
                    _current = default;
                    return false;
                }}
            }}

            public void Reset()
            {{
                _currentIndex = -2;
            }}
        }}

        #endregion

        public void* this[nuint index]
        {{
            get
            {{
                if (Size <= 0 || Size <= index)
                {{
                    throw new Exception(""Element outside the stack"");
                }}

                return
                    (byte*)_start + ((Size - 1 - index) * {currentType.Name}Helper.GetSize());
            }}
        }}

        public void Copy(in void* ptrDest)
        {{
            Buffer.MemoryCopy(
                _start,
                ptrDest,
                Capacity * {currentType.Name}Helper.GetSize(),
                Capacity * {currentType.Name}Helper.GetSize()
                );
        }}
    }}
}}
");
                context.AddSource($"{currentType.Name}StackClass.g.cs", helperBuilder.ToString());
            }
        }
    }
}